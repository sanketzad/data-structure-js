// Graph data structure

/**
 * * Graph Data Structure
 * * A graph is a collection of nodes (also called vertices) and edges that connect them.
 * * Graphs can be directed or undirected, weighted or unweighted, and can have cycles or be acyclic.
 * 
 * Types of Graphs:
 * 1. Directed Graph: A graph where edges have a direction, meaning they go from one node to another.
 * 2. Undirected Graph: A graph where edges do not have a direction, meaning they connect two nodes bidirectionally.
 * 3. Weighted Graph: A graph where edges have weights, representing the cost or distance between nodes.
 * 4. Unweighted Graph: A graph where edges do not have weights, meaning all edges are equal.
 * 5. Cyclic Graph: A graph that contains at least one cycle, meaning there is a path that starts and ends at the same node.
 * 6. Acyclic Graph: A graph that does not contain any cycles.
 * 7. Directed Acyclic Graph (DAG): A directed graph that does not contain any cycles.
 * 8. Complete Graph: A graph where every pair of nodes is connected by an edge.
 * 9. Sparse Graph: A graph with relatively few edges compared to the number of nodes.
 * 10. Dense Graph: A graph with a large number of edges compared to the number of nodes.
 * 11. Bipartite Graph: A graph whose nodes can be divided into two disjoint sets such that no two nodes within the same set are adjacent.
 * 12. Tree: A special type of graph that is connected and acyclic, where there is exactly one path between any two nodes.
 * 13. Forest: A collection of trees, which is a disjoint set of acyclic graphs.
 * 14. Planar Graph: A graph that can be drawn on a plane without any edges crossing.
 * 15. Multigraph: A graph that allows multiple edges between the same pair of nodes.
 * 16. Hypergraph: A generalization of a graph where edges can connect more than two nodes.
 * 17. Subgraph: A graph formed from a subset of the nodes and edges of another graph.
 * 18. Complement Graph: A graph that contains all the edges that are not present in the original graph.
 * 19. Random Graph: A graph generated by some random process, often used in probabilistic analysis.
 * 20. Directed Multigraph: A directed graph that allows multiple edges between the same pair of nodes.
 * 
 * * Graph Representation:
 * 1. Adjacency List: A list where each node has a list of its neighbors.
 * Example: It can represented by an object where keys are the nodes and values are the arrays of adjacent nodes
 * ```javascript
 * const graph = {
 *     a: ["b", "c"],
 *     b: ["a", "d"],
 *     c: ["a", "e"],
 *     d: ["b", "f"],
 *     e: ["c"],
 *     f: ["d"]
 * };
 * ```
 * 2. Adjacency Matrix: A 2D array where the cell at (i, j) indicates whether there is an edge from node i to node j.
 * Example: It can represented by a 2D array where the rows and columns are the nodes and the values are 1 or 0 indicating the presence or absence of an edge
 * ```javascript
 * const graph = [
 *     [0, 1, 1, 0, 0, 0], // a
 *     [1, 0, 0, 1, 0, 0], // b
 *     [1, 0, 0, 0, 1, 0], // c
 *     [0, 1, 0, 0, 0, 1], // d
 *     [0, 0, 1, 0, 0, 0], // e
 *     [0, 0, 0, 1, 0, 0]  // f
 * ];
 * ```
 * 3. Edge List: A list of edges, where each edge is represented as a pair of nodes.
 * Example: It can represented by an array of arrays where each array is a pair of nodes
 * ```javascript
 * const edges = [
 *     ["a", "b"],
 *     ["a", "c"],
 *     ["b", "d"],
 *     ["c", "e"],
 *     ["d", "f"],
 *     ["e", "f"]
 * ];
 * ```
 */
class Graph {
    constructor() {
        this.adjacencyList = {};
        this.noOfNodes = 0;
    }

    addNode (node) {
        if (!this.adjacencyList[node]) {
            this.adjacencyList[node] = [];
            this.noOfNodes++;
        }

        return this.adjacencyList;
    }

    addEdge (node1, node2) {
        if (!this.adjacencyList[node1]) {
            this.newNode(node1);
        }
        if (!this.adjacencyList[node2]) {
            this.newNode(node2);
        }

        this.adjacencyList[node1].push(node2);
        this.adjacencyList[node2].push(node1); // For undirected graph, add the edge in both directions

        return this.adjacencyList;
    }
}


/**
 * Graph = nodes + edges
 * 
 * Graph consists of nodes and edges. Each node can have multiple edges to the other nodes.\
 * The graph can be directed or undirected. In a directed graph the edges have a direction. But in undirected graph the edges do not have a direction.
 * 
 */

// Depth First Search (DFS) is a graph traversal algorithm that starts at the root node and explores as far as possible along each branch before backtracking. It uses a stack data structure to keep track of the nodes to be visited next. The algorithm can be implemented using recursion or an explicit stack.

function depthFirstTraversal(graph, source) {
    const stack = [source];
    const result = [];

    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node);

        for (const neighbor of graph[node].reverse()) {
            stack.push(neighbor);
        }
    }

    return result;
}

function depthFirstTraversalRecursive(graph, source, result = []) {
    if (!graph) return result;
    if (!graph[source]) return result;

    result.push(source);

    for (const neighbor of graph[source].reverse()) {
        depthFirstTraversalRecursive(graph, neighbor, result);
    }

    return result;
}

function breadthFirstTraversal(graph, source) {
    const queue = [ source ];
    const result = [];

    while (queue.length > 0) {
        const node = queue.shift();
        result.push(node);

        for (const neighbor of graph[node]) {
            queue.push(neighbor);
        }
    }

    return result;
}

/**
 * * Graph Traversal Algorithms
 */

/**
 * * 1. Has path - Depth First Traversal Recursive
 * 
 * * Given a graph and two nodes, determine if there is a path between the two nodes.
 * Time and space complexity: consider the n as # of nodes in the graph and v as # of edges in the graph
 * Time complexity = O(n + v)
 * Space complexity = O(n)
 * 
 * Worst case:
 * Time complexity = O(n ** 2)
 * Space complexity = O(n)
 * 
 * @params {Object} graph - The graph to be traversed
 * @params {String} source - The source node to start the traversal
 * @params {String} target - The target node to be reached
 * @returns {Boolean} - True if there is a path between the two nodes, false otherwise
 */
function hasPathDFTRecursive(graph, source, target) {
    if (source === target) return true;

    for (const neighbor of graph[source]) {
        if (hasPathDFTRecursive(graph, neighbor, target)) {
            return true;
        }
    }

    return false;
}

/**
 * * 2. Has path - Depth First Traversal Iterative
 * 
 * * Given a graph and two nodes, determine if there is a path between the two nodes.
 * Time and space complexity: consider the n as # of nodes in the graph and v as # of edges in the graph
 * Time complexity = O(n + v)
 * Space complexity = O(n)
 * 
 * Worst case:
 * Time complexity = O(n ** 2)
 * Space complexity = O(n)
 * 
 * @params {Object} graph - The graph to be traversed
 * @params {String} source - The source node to start the traversal
 * @params {String} target - The target node to be reached
 * @returns {Boolean} - True if there is a path between the two nodes, false otherwise
 */
function hasPathDFT(graph, source, target) {
    const stack = [ source ];

    while (stack.length > 0) {
        const node = stack.pop();
        if (node === target) return true;

        for (const neighbor of graph[node]) {
            stack.push(neighbor);
        }
    }

    return false;
}

/**
 * * 3. Has path - Breadth First Traversal
 * 
 * * Given a graph and two nodes, determine if there is a path between the two nodes.
 * Time and space complexity: consider the n as # of nodes in the graph and v as # of edges in the graph
 * Time complexity = O(n + v)
 * Space complexity = O(n)
 * 
 * Worst case:
 * Time complexity = O(n ** 2)
 * Space complexity = O(n)
 * 
 * @params {Object} graph - The graph to be traversed
 * @params {String} source - The source node to start the traversal
 * @params {String} target - The target node to be reached
 * @returns {Boolean} - True if there is a path between the two nodes, false otherwise
 */
function hasPathBFT(graph, source, target) {
    const queue = [ source ];

    while (queue.length > 0) {
        const node = queue.shift();

        if (node === target) return true;

        for (const neighbor of graph[node]) {
            queue.push(neighbor);
        }
    }

    return false;
}

/**
 * * 4. Undirected path of the graph - Depth First Traversal
 * All the edges will not have a direction. So the graph will be undirected.
 * To solve this problem, we need to build the adjecency list of the graph and then traverse tge graph to find the path.
 * 
 * @params {Array} edges - The edges of the graph
 * @params {String} nodeA - The source node to start the traversal
 * @params {String} nodeB - The target node to be reached
 * @returns {Boolean} - True if there is a path between the two nodes, false otherwise
 */
function undirectedPath(edges, nodeA, nodeB) {
    const graph = buildGraph(edges);

    return _hasPath(graph, nodeA, nodeB, new Set());
}

function _hasPath(graph, source, target, visited) {
    if (source === target) return true;
    if (visited.has(source)) return false;
    visited.add(source);

    for (const neighbor of graph[source]) {
        if (_hasPath(graph, neighbor, target, visited)) {
            return true;
        }
    }

    return false;
}

function buildGraph(edges) {
    const graph = {};

    for (const edge of edges) {
        const [ a, b ] = edge;
        if (!graph[a]) graph[a] = [];
        if (!graph[b]) graph[b] = [];
        graph[a].push(b);
        graph[b].push(a);
    }

    return graph;
}

/**
 * * 5. Connected components of the graph & count
 * 
 * @params {Object} graph - The graph to be traversed
 * @returns {Number} - The number of connected components in the graph
 */
function connectComponentsCount(edges) {
    const graph = buildGraph(edges);
    const visited = new Set();
    let count = 0;

    for (let node in graph) {
        if (explore(graph, node, visited)) {
            count++;
        };
    }

    return count;
}

function explore(graph, current, visited) {
    if (visited.has(current)) return false;

    visited.add(current);

    for (const neighbor of graph[current]) {
        explore(graph, neighbor, visited);
    }

    return true;
}

/**
 * * 6. Largest component of the graph
 * Determine the largest component of the graph among all the island of components
 * 
 * @params {Object} graph - The graph to be traversed
 * @returns {Number} - The size of the largest component in the graph
 */
function largestComponent(graph) {
    const visited = new Set();
    let largest = 0;
    for (let node in graph) {
        const size = exploreLargest(graph, node, visited);
        if (size > largest) {
            largest = size;
        }
    }

    return largest;
}

function exploreLargest(graph, node, visited) {
    if (visited.has(node)) return 0;
    visited.add(node);
    let size = 1;

    for (const neighbor of graph[node]) {
        size += exploreLargest(graph, neighbor, visited);
    }

    return size;
}

/**
 * * 7. Shortest path of the graph
 * 
 * @params {Array} edges - The graph to be traversed
 * @params {String} source - The source node to start the traversal
 * @params {String} target - The target node to be reached
 * @returns {Number} - The shortest path between the two nodes. If not found return -1
 */
function shortestPath(edges, source, target) {
    const graph = buildGraph(edges);
    console.log(graph)
    const queue = [ source ];
    const visited = new Set();

    const distance = { [source]: 0 };
    visited.add(source);

    while (queue.length > 0) {
        const node = queue.shift();
        if (node === target) return distance[node];
        for (const neighbor of graph[node]) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push(neighbor);
                distance[neighbor] = distance[node] + 1;
            }
        }
    }

    return -1;
}

/**
 * * 8. Island count
 * * Given a grid of 0s and 1s or w and l, where 1s/l represent land and 0s/w represent water, count the number of islands in the grid.
 * 
 * @params {Array} grid - The grid to be traversed
 * @returns {Number} - The number of islands in the grid
 */
function islandCount(grid) {
    const visited = new Set();
    let count = 0;

    // Loop through each cell in the grid
    for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid[0].length; c++) {
            if (exploreIsLand(grid, r, c, visited) === true) {
                count += 1;
            };
        }
    }

    return count;
}

function exploreIsLand(grid, r, c, visited) {
    const rowInbounds = 0 <= r && r < grid.length;
    const colInbounds = 0 <= c && c < grid[0].length;
    if (!rowInbounds || !colInbounds) return false;

    // Check if the cell is water or already visited, return false.
    if (grid[r][c] === "w") return false;

    const pos = `${r},${c}`;
    if (visited.has(pos)) return false;
    visited.add(pos);

    // Exlpore all the neighbors of the cell
    exploreIsLand(grid, r - 1, c, visited); // up
    exploreIsLand(grid, r + 1, c, visited); // down
    exploreIsLand(grid, r, c - 1, visited); // left
    exploreIsLand(grid, r, c + 1, visited); // right

    return true;
}

/**
 * * 9. Minimum island size
 * * Given a grid of 0s and 1s or w and l, where 1s/l represent land and 0s/w represent water, find the size of the smallest island in the grid.
 * @params {Array} grid - The grid to be traversed
 * @returns {Number} - The size of the smallest island in the grid
 */
function minimumIsland(grid) {
    const visited = new Set();
    let minimum = Infinity;

    for (let r = 0; r < grid.length; r++) {
        for (let c = 0; c < grid[0].length; c++) {
            const size = exploreIslandSize(grid, r, c, visited);
            if (size > 0 && size < minimum) {
                minimum = size;
            }
        }
    }

    return minimum;
}

function exploreIslandSize (grid, r, c, visited) {
    const rowInbounds = 0 <= r && r < grid.length;
    const colInbounds = 0 <= c && c < grid[0].length;
    if (!rowInbounds || !colInbounds) return 0;

    // Check if the cell is water or already visited, return 0.
    if (grid[r][c] === "w") return 0;

    const pos = `${r},${c}`;
    if (visited.has(pos)) return 0;
    visited.add(pos);
    let size = 1;

    // Exlpore all the neighbors of the cell
    for (const [ dr, dc ] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
        size += exploreIslandSize(grid, r + dr, c + dc, visited);
    }

    return size;
}

const graph1 = {
    0: ["8", "1", "5"],
    1: ["0"],
    2: ["3", "4"],
    3: ["2", "4"],
    4: ["2", "3"],
    5: ["0", "8"],
    8: ["0", "5"],
}

const grid = [
    ["w", "l", "w", "w", "w"],
    ["w", "l", "w", "w", "w"],
    ["w", "w", "w", "l", "w"],
    ["w", "w", "l", "l", "w"],
    ["l", "w", "w", "l", "l"],
    ["l", "l", "w", "w", "w"],
];

const graph = {
    a: ["b", "c"],
    b: ["d"],
    c: ["e"],
    d: ["f"],
    e: [],
    f: []
}

const edges = [
    ["i", "j"],
    ["k", "i"],
    ["m", "k"],
    ["k", "l"],
    ["o", "n"],
];

const edges1 = [
    ["w", "x"],
    ["x", "y"],
    ["z", "y"],
    ["z", "v"],
    ["v", "w"],
];

console.log(depthFirstTraversal(graph, "a"));
console.log(depthFirstTraversalRecursive(graph, "a"));
console.log(breadthFirstTraversal(graph, "a"));
console.log(hasPathDFT(graph, "a", "f")); // true
console.log(hasPathDFT(graph, "a", "g")); // false
console.log(hasPathDFTRecursive(graph, "a", "f")); // true
console.log(hasPathDFTRecursive(graph, "a", "g")); // false
console.log(hasPathBFT(graph, "a", "f")); // true
console.log(hasPathBFT(graph, "a", "g")); // false
console.log(undirectedPath(edges, "i", "j")); // true
console.log(undirectedPath(edges, "i", "o")); // false
// console.log(connectComponentsCount(graph)); // 1
console.log(connectComponentsCount(edges)); // 2
console.log(largestComponent(graph1)); // 4
console.log(largestComponent(graph)); // 6
console.log(shortestPath(edges1, "w", "z")); // 2
console.log(islandCount(grid)); // 3
console.log(minimumIsland(grid)); // 2